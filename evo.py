"""
Evo - an evolution simulator framework

Tony Zoltai, July 2017

General template classes for evolutionary simulation.

"""

"""
NOTES

gene:   genes have IDs, and a list of alleles.  All genes have at least one allele

mutation: the  creation record of a new allele, or a new gene

allele: generated by mutation from another allele. has an ID.  Genetics classes can express alleles, to add to a phenotype.
    an allele carries a history of mutations 

block - a linkage block, i.e a list of alleles within a chromosome.
    in extracting a haploid genome, either all or none of the alleles in a block are copied

chromosome: has an id; a list of blocks.  can also represent a plasmid
    



genetics:
- how genotypes combine?
-default_genome
- random_genome
- express a genome - return a phenotype (implement dominance scheme)
- extract gamete/poly_to_monoploid: from a genome, return a haploid genome
- construct zygote/mono-to-diploid: combine two monoploid genomes

dominance:  function of two alleles

genome:
a list of chromosomes (some might be plasmids)



A list of chromosomes, which are tuples of ploids, which are lists of blocks,which are lists of genes; mutations in the same block are inherited together.
The simplest structure of a genome is a single chromosome, being a 1-tuple of a list of one block.
Genomes are inert - they store genetic information but have no behaviour other than retrieval.
- iterator: chromosomes
- iterator: blocks
- iterator: genes
ALTERNATIVE - a genome is a dict; chromosome/plasmid positions are the keys, tuples of chromosomes are the values.
a chromosome is a list of blocks
a block is a list of alleles


sexual reproduction:
implemented i n genetics
For each parent's genome, extract a haploid genome (for a gamete), respecting linkage blocks
For each chromosome id in either parent's gamete, make a pair or 1-tuple with the chromosomes present and add to the zygote genome
    


"""

import random

class Genome(dict):
    def __init__(self, rng = None):
        self.rng = rng if rng != None else random.Random()
        super(Genome, self).__init__(self)
    def __missing__(self, key):
        return ()
    def add_chromosome(self, chromosome, tag = None):
        self[tag] = self[tag] + (chromosome,)
    def get_haploid(self):
        h = Genome()
        for k in self.keys():
            h.add_chromosome(self.rng.choice(self[k]), k)
        return h

class Chromosome(object):
    def __init__(self):
        self.blocks = []
    def add_block(block):
        self.blocks.append(block)



class FixedLengthStringGenetics(object):
    def __init__(self, alphabet, length):
        self.alphabet = alphabet
        self.length = length
        self.rng = random.Random()

    def random_genotype(self):
        return ''.join([self.rng.choice(self.alphabet) for i in range(self.length)])

    def copy_genotype(self, g):
        i = self.rng.randint(0,self.length - 1)
        return g[:i] + self.rng.choice(self.alphabet) + g[i + 1:]


class Individual(object):
    """An individual of an evolving population."""

    def __init__(self, genotype, identity = None, alive = True):
        self.genotype = genotype
        self.identity = identity
        self.alive = alive

    def reproductive(self):
        return True

    def phenotype(self):
        return self.genotype

    def get_gamete(self, environment):
        return None

    def dump(self):
        print "Identity:", self.identity
        print "Genotype:", self.genotype



class Genealogy(object):
    """A genealogy of individuals."""

    def __init__(self):
        self.register = []

    def next_identity(self):
        return len(self.register)

    def birth(self, mother, birth_details = None, genes = None):
        i = self.next_identity()
        self.register.append([birth_details, None, [(mother, genes)]])
        return i

    def add_parent(self, identity, parent, genes):
        self.register[identity][2].append((parent, genes))

    def death(self, identity, death_details = True):
        self.register[identity][1] = death_details

    def dead(self, identity):
        return self.register[identity][1] != None

    def dump(self):

        def dumpreg(i):
            e = self. register[i]
            print 'Individual ' + str(i) + ': '
            print 'Birth: ', e[0]
            print 'Death: ', e[1]
            print 'Parents: ', e[2]
            
        print 'Individuals recorded: ', len(self.register)
        for i in range(len(self.register)):
            dumpreg(i)

class Environment(object):
    def __init__(self, params = None):
        self.params = params
    def fitness(self, phenotype):
        return 1.0


class WeaselEnvironment(object):
    def __init__(self, params = 'weasel'):
        self.params = params
    def fitness(self, phenotype):
        r = 0
        for i, j in zip(self.params, phenotype):
            r -= abs(ord(j) - ord(i))
        return r


class SimpleEvoModel(object):
    """
        Start with a populaton of N random genotypes.
        In each cycle, copy individuals in order of decreasong fitness to the next generation, with each spawning F mutated clones,,
        until the population cap of N is full.
    """
    def __init__(self, ind_class, environment, genetics, pop_cap = 100, offspring_count = 1):
        self.ind_class = ind_class
        self.env = environment
        self.gen = genetics
        self.pop_cap = pop_cap
        self.offspring_count = offspring_count
        self.cycle_count = 0
        self.robd = Genealogy()
        self.population = []
        for i in range(pop_cap):
            genotype = genetics.random_genotype()
            ident = self.robd.birth(None, None, genotype)
            self.population.append(ind_class(genotype, ident))

    def dump(self):
        for i in self.population:
            print i.identity, i.genotype

    def cycle(self):
        def sortkey(p):
            return self.env.fitness(p.phenotype())

        ranking = sorted(self.population, key = sortkey, reverse = True)
        #print [(self.env.fitness(r.phenotype()), r.phenotype()) for r in ranking]
        n = []
        for i in ranking:
            if len(n) < self.pop_cap:
                n.append(i)
            for j in range(self.offspring_count):
                if len(n) < self.pop_cap:
                    g = self.gen.copy_genotype(i.genotype)
                    ident = self.robd.birth(i.identity, None, g)
                    n.append(self.ind_class(g, ident))
        self.population = n
        self.cycle_count += 1
            



if __name__ == '__main__':

#    r = random.Random()
#    g = Genome(r)
#
#    g.add_chromosome(3,0)
#    g.add_chromosome(4,0)
#    g.add_chromosome(5,1)
#    g.add_chromosome(6,2)
#    g.add_chromosome(7,2)
#
#    print g
#
#    print g.get_haploid()
#    print g.get_haploid()


    print '--------------------'
#    alphabet = [chr(v) for v in range(ord('a'), ord('z') + 1)] + [' ']
    alphabet = 'ACGT'
    perfection = 'TACT' * 19
    print alphabet
    print perfection
    m = SimpleEvoModel(Individual, WeaselEnvironment(perfection), FixedLengthStringGenetics(alphabet, len(perfection)), 10)
    m.dump()
    while m.population[0].phenotype() != perfection:
        m.cycle()
        print '--------------------', m.cycle_count
        m.dump()
